<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>葡萄藤PPT</title>
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">
    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">
    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">
    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>JAVA------反射</h2>
            <h3>java 小课堂</h3>
            <p>分享人：常雷雷</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p>反射主要是指程序可以访问，检测和修改它本身状态或行为，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义的一种能力。</p>
            <p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；</p>
            <p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
        </section>
        <section>
            <p>在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。可以说类中有什么信息，就可以利用反射机制获得什么信息。</p>
            <p>反射机制，能够使我们很方便的创建灵活的代码，</p>
            <p>这些代码可以在运行时装配，而无需在组件之间进行源代码链接。在java中是一种非常强大的功能。</p>
            <P>但是反射使用不当会影响到程序的性能。</P>
        </section>
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <P style="color: blue">反射是框架设计的灵魂</P>
            <P style="color: blue">要正确使用Java反射机制就得使用java.lang.Class类。它是Java反射机制的起源。</P>
            <P><img src="A:\正则表达式\反射.png"/></p>
        </section>
        <section>
            <p>Class提供了四个public方法，用于获取类的构造方法。</p><p>
            <p>Constructor getConstructor(Class[] params) </p><p>根据构造函数的参数，返回一个具体的具有public属性的构造函数</p>
            <p>Constructor getConstructors() </p><p>返回所有具有public属性的构造函数数组</p>
            <p>Constructor getDeclaredConstructor(Class[] params)</p><p> 根据构造函数的参数，返回一个具体的构造函数（不分public和非public属性）</p>
            <p>Constructor getDeclaredConstructors() </p><p>返回该类中所有的构造函数数组（不分public和非public属性）</p>
        </section>
        <section>
            <p>四种获取成员方法的方法</p>
            <p>Method getMethod(String name, Class[] params)</p><p>根据方法名和参数，返回一个具体的具有public属性的方法</p>
            <p>Method[] getMethods() </p><p>返回所有具有public属性的方法数组</p>
            <p>Method getDeclaredMethod(String name, Class[] params) </p><p>根据方法名和参数，返回一个具体的方法（不分public和非public属性）</p>
            <p>Method[] getDeclaredMethods() </p><p>返回该类中的所有的方法数组（不分public和非public属性）</p>
        </section>
        <section>
            <p>四种获取成员属性的方法</p>
            <p>Field getField(String name)</p><p> 根据变量名，返回一个具体的具有public属性的成员变量</p>
            <p>Field[] getFields() </p><p>返回具有public属性的成员变量的数组</p>
            <p>Field getDeclaredField(String name)</p><p> 根据变量名，返回一个成员变量（不分public和非public属性）</p>
            <p>Field[] getDelcaredField() </p><p>返回所有成员变量组成的数组（不分public和非public属性）</p>
        </section>
        <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
            <p>1.反射的优缺点？</p>
        </section>
        <section>
            <h3>4.解决方案</h3>
        </section>
        <section>
            <p>优点：</p>
            <p> 1、反射提高了程序的灵活性和扩展性。</p>
            <p>2、降低耦合性，提高自适应能力。</p>
            <p>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</p>
        </section>
        <section>
            <p>缺点：</p>
            <p>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。</p>
            <p>因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</p>
            <p>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</p>
        </section>
        <section>
            <h3>5.编码实战</h3>
            <p>让我们来看看这个例子的代码。</p>
        </section>
        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
            <p>反射创建对象比直接创建对象慢，为什么还要使用反射？</p>
        </section>
        <section>
        </section>
        <section>
            <h3>7.参考文献</h3>
            <p>链接：https://www.cnblogs.com/Eason-S/p/5851078.html</p>
            <p>作者：Eason-S</p>
            <p>链接：http://www.cnblogs.com/zhaoyanjun/p/6074887.html</p>
            <p>作者：luoxn28</p>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢观看,如有出错,恳请指正</p>
            <p>
                <small>BY : 深圳分院 常雷雷</small>
            </p>
        </section>
    </div>
</div>
<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>
<script>
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true},
            {
                src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>


<!--XMemcached配置-->

<bean id="memcachedClientBuilder" class="net.rubyeye.xmemcached.XMemcachedClientBuilder">
    <constructor-arg>
        <list>
            <bean class="java.net.InetSocketAddress">
                <constructor-arg value="39.108.78.2"/>
                <constructor-arg value="11211"/>
            </bean>
        </list>
    </constructor-arg>
    <property name="connectionPoolSize" value="50"/>
    <property name="commandFactory">
        <bean class="net.rubyeye.xmemcached.command.BinaryCommandFactory"/>
    </property>
    <property name="transcoder">
        <bean class="net.rubyeye.xmemcached.transcoders.SerializingTranscoder"/>
    </property>
</bean>
<!-- Use factory bean to build memcached client -->
<bean id="memcachedClient"
      factory-bean="memcachedClientBuilder"
      factory-method="build"
      destroy-method="shutdown">
</bean>
